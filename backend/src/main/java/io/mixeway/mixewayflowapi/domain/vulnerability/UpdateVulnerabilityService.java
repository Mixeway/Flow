package io.mixeway.mixewayflowapi.domain.vulnerability;

import com.google.genai.errors.ClientException;
import com.google.genai.errors.ServerException;
import io.mixeway.mixewayflowapi.api.constraint.service.ConstraintService;
import io.mixeway.mixewayflowapi.db.entity.Vulnerability;
import io.mixeway.mixewayflowapi.db.repository.VulnerabilityRepository;
import io.mixeway.mixewayflowapi.exceptions.VulnerabilityException;
import io.mixeway.mixewayflowapi.integrations.gemini.service.GeminiVulnerabilityService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.List;


/**
 * Service class responsible for updating the details of a {@link Vulnerability}.
 * This service allows patching (partial update) of a vulnerability's description, reference, and recommendation.
 */
@Service
@RequiredArgsConstructor
@Log4j2
public class UpdateVulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ConstraintService constraintService;
    private final GeminiVulnerabilityService geminiVulnerabilityService;
    private final FindVulnerabilityService findVulnerabilityService;

    /**
     * Updates the specified fields of a {@link Vulnerability} entity.
     *
     * @param id The ID of the vulnerability to update.
     * @param description The new description for the vulnerability.
     * @param ref The new reference for the vulnerability.
     * @param recommendation The new recommendation for the vulnerability.
     * @throws VulnerabilityException if the vulnerability with the given ID does not exist.
     */
    public void patch(Long id, String description, String ref, String recommendation) {
        // Fetch the vulnerability from the repository, throw an exception if not found
        Vulnerability vulnerability = vulnerabilityRepository.findById(id).orElseThrow();

        // Update the vulnerability's fields
        vulnerability.patch(description, ref, recommendation);

        // Save the updated vulnerability back to the repository
        vulnerabilityRepository.save(vulnerability);

        // Log the update operation
        log.info("[Update Vulnerability] Updating description for {}", vulnerability.getName());
    }

    public void addExploit(Vulnerability vulnerability, String vector){
        vulnerability.updateKevInfos(true);
        vulnerability.updateVector(vector);
        vulnerabilityRepository.save(vulnerability);
        log.info("[Update Vulnerability] Added exploit to {}", vulnerability.getName());
    }

    @Scheduled(fixedDelay = 30 * 60 * 1000, initialDelay = 1 * 10 * 1000)
    public List<Vulnerability> updateAllConstraints() {
        long cnt = findVulnerabilityService.getAll()
                .stream()
                .filter(e -> e.getConstraints().isEmpty())
                        .count();
        log.info("Vulnerabilities that left to be updated: {}", cnt);
        return findVulnerabilityService.getAll()
                                        .stream()
                                        .filter(e -> e.getConstraints().isEmpty())
                                        .map(this::updateConstraint)
                                        .toList();
    }

    public List<Vulnerability> updateConstraintsForVulnerabilityById(long id) {
        return findVulnerabilityService.getById(id)
                .stream()
                .map(this::updateConstraint)
                .toList();
    }

    @Async
    @EventListener
    public void handleVulnerabilityUpdate(VulnerabilityEvent vulnerabilityEvent) {
        log.info("Updating vulnerability after the INSERT or UPDATE statement, id:{}", vulnerabilityEvent.getVulnerability().getId());
        updateConstraint(vulnerabilityEvent.getVulnerability());
    }

    private Vulnerability updateConstraint(Vulnerability vulnerability) {
        log.info("Updating constraints for the vulnerability id:{}", vulnerability.getId());

        if(!vulnerability.getConstraints().isEmpty()) {
            log.info("Vulnerability has constraints already defined, skipping.");
            return vulnerability;
        }

        String vulnerabilityDescription =
                "Name: " + vulnerability.getName() + "; Description: " + vulnerability.getDescription();

        try {
            List<String> constraints = geminiVulnerabilityService.analyzeVulnerability(vulnerabilityDescription);
            constraints.forEach(c -> constraintService.createConstraint(vulnerability.getId(), c));
        } catch (ClientException | InterruptedException | ServerException e) {
            log.error("Error occurred while processing: {}", e.getLocalizedMessage());
        }

        return vulnerability;
    }
}
